<!DOCTYPE html>
<html lang="en-US">

<head>
<title>Lua extensions</title>
<base href="" target="_self" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="application-name" content="LVS">
<meta name="author" content="Youka">
<meta name="description" content="Lua extensions reference.">
<meta name="keywords" content="LVS,Lua,Image,2D,Editing">
<link rel="icon" type="image/png" href="LVS.png">
<style type="text/css" media="screen">
	body{
		background-color: black;
		color: white;
		margin: 10px;
	}
	h1{
		font-size: 36px;
		font-weight: bold;
		color: black;
		background-color: #F0F0F0;
		border: 3px solid grey;
		display: table;
		margin: 0px;
	}
	h2{
		font-size: 20px;
		text-decoration: underline overline;
		margin: 10px 0px 10px 0px;
	}
	hr{
		height: 0px;
		border: 3px ridge grey;
	}
	p{
		margin: 0px 0px 0px 10px;
	}
	p.def{
		color: black;
		background-color: #F0F0F0;
		display: table;
		border: 2px groove black;
		font-weight: bold;
	}
	div.index{
		color: black;
		background-color: white;
		border: 8px groove red;
		display: inline-block;
		overflow-y: scroll;
		height: 80%;
		position: fixed; right: 0px; top: 0px;
		width: 0px;
		padding-top: 10px;
		padding-bottom: 10px;
	}
	div.index:hover{
		width: auto;
		padding: 10px;
	}
	a.index{
		text-decoration: none;
		color: black;
		display: block;
	}
	span.index_h1, span.index_h2{
		font-weight: bold;
		display: block;
		text-decoration: underline;
	}
	span.index_h1{
		text-align: center;
	}
	span.index_h2{
		font-style: italic;
	}
</style>
<script type="text/javascript">
var index_buffer = "";

function Title1(text){
	document.write("<h1>"+text+"</h1>");
	index_buffer += "<span class='index_h1'>"+text+"</span>";
}
function Title2(text){
	document.write("<h2>"+text+"</h2>");
	index_buffer += "<span class='index_h2'>"+text+"</span>";
}
function Separator(){
	document.write("<hr/>");
}
function VarEntry(v){
	document.write("<p class='def'><a name='"+v+"'>"+v+"</a></p>");
	index_buffer += '<a class="index" href="#'+v+'">'+v+'</a>';
}
function FuncEntry(ret, func, arguments){
	var buffer = "<p class='def'><a name='"+func+"'>";
	if(ret.length > 0)
		buffer += "<span style='color: green;'>"+ret+"</span> = ";
	buffer += func+"(";
	if(arguments.length > 0)
		buffer += "<span style='color: red;'>"+arguments+"</span>";
	buffer += ")</a></p>";
	document.write(buffer);
	index_buffer += '<a class="index" href="#'+func+'">'+func+'</a>';
}

function Desc(text){
	document.write("<p>"+text+"</p>");
}
function BeginArgs(){
	document.write("<div style='margin: 0px 0px 10px 30px;'>");
}
function Arg(arg, desc){
	document.write("<div><span style='color: red;'>"+arg+"</span>: "+desc+"</div>");
}
function Ret(arg, desc){
	document.write("<div><span style='color: green;'>"+arg+"</span>: "+desc+"</div>");
}
function EndArgs(){
	document.write("</div>");
}
</script>
</head>

<body>
<div id="index" class="index">
</div>
<script>
Title1("Math");
FuncEntry("point", "math.bezier", "pct, points");
Desc("Calculates a point on bezier curve.");
BeginArgs();
Arg("pct", "number in range 0-1");
Arg("points", "curve points in 2D or 3D (table)");
Ret("point", "3D point on curve (table)");
EndArgs();
FuncEntry("deg", "math.degree", "vec1, vec2");
Desc("Calculates degree between two vectors.");
BeginArgs();
Arg("vec1", "first 2D or 3D vector (table)");
Arg("vec2", "second 2D or 3D vector (table)");
Ret("deg", "degree between vectors (number)");
EndArgs();
FuncEntry("len", "math.distance", "w, h[, d]");
Desc("Calculates vector length.");
BeginArgs();
Arg("w", "width (number)");
Arg("h", "height (number)");
Arg("d", "depth (number, optional)");
Ret("len", "length (number)");
EndArgs();
FuncEntry("x, y", "math.ellipse", "cx, cy, w, h, a");
Desc("Calculates an ellipse point.");
BeginArgs();
Arg("cx, cy", "ellipse center (number)");
Arg("w, h", "ellipse dimension (number)");
Arg("a", "ellipse angle (number)");
Ret("x, y", "point on ellipse (number)");
EndArgs();
FuncEntry("res", "math.inrange", "min, max, value");
Desc("Calculates whether <i>value</i> is in range <i>min</i> until <i>max</i> and how far.");
BeginArgs();
Arg("min", "minimal number");
Arg("max", "maximal number");
Arg("value", "any number");
Ret("res", "number or nil");
EndArgs();
FuncEntry("res", "math.interpolate", "min, max, pct");
Desc("Calculates a number between two numbers by <i>pct</i>.");
BeginArgs();
Arg("min", "minimal number");
Arg("max", "maximal number");
Arg("pct", "number in range 0-1");
Ret("res", "interpolation result (number)");
EndArgs();
FuncEntry("vec", "math.ortho", "vec1, vec2");
Desc("Calculates the orthogonal vector of two given vectors.");
BeginArgs();
Arg("vec1", "first 3D vector (table)");
Arg("vec2", "second 3D vector (table)");
Ret("vec", "orthogonal 3D vector (table)");
EndArgs();
FuncEntry("n", "math.randomsteps", "min, max, step");
Desc("Generates a random number in range <i>min</i> until <i>max</i> and with gaps of <i>step</i>.");
BeginArgs();
Arg("min", "minimal number");
Arg("max", "maximal number");
Arg("step", "gap size (number)");
Ret("n", "random number");
EndArgs();
FuncEntry("n", "math.round", "num");
Desc("Rounds a number.");
BeginArgs();
Arg("num", "any number");
Ret("n", "integer");
EndArgs();
FuncEntry("result", "math.trim", "num, min, max");
Desc("Returns the result of number trimming to range <i>min</i> until <i>max</i>.");
BeginArgs();
Arg("num", "any number");
Arg("min", "minimal number");
Arg("max", "maximal number");
Ret("result", "trimmed number");
EndArgs();
Separator();
Title1("String");
FuncEntry("len", "string.ucharrange", "s, pos");
Desc("Returns length of an unicode character at given position in text.");
BeginArgs();
Arg("s", "unicode text (string)");
Arg("pos", "text position (number)");
Ret("len", "byte length (number)");
EndArgs();
FuncEntry("ci, char", "string.uchars", "s");
Desc("Iterator function for unicode text characters.");
BeginArgs();
Arg("s", "unicode text (string)");
Ret("ci", "index of unicode character (number)");
Ret("char", "unicode character (string)");
EndArgs();
FuncEntry("len", "string.ulen", "s");
Desc("Returns length of an unicode text.");
BeginArgs();
Arg("s", "unicode text (string)");
Ret("len", "unicode characters number (number)");
EndArgs();
Separator();
Title1("Table");
FuncEntry("t2", "table.copy", "t1")
Desc("Creates a deep table copy.");
BeginArgs();
Arg("t1", "any table");
Ret("t2", "table copy");
EndArgs();
FuncEntry("t", "table.create", "array_size, hash_size")
Desc("Creates a table with reserved memory.");
BeginArgs();
Arg("array_size", "size of table array part (number)");
Arg("hash_size", "size of table hash part (number)");
Ret("t", "table with custom size");
EndArgs();
FuncEntry("distro", "table.distributor", "t")
Desc("Sets a metatable to given table for continuous element getting.");
BeginArgs();
Arg("t", "any table")
Ret("distro", "table from input with method <i>get()</i>");
EndArgs();
FuncEntry("info", "table.tostring", "t")
Desc("Returns a table as string.")
BeginArgs();
Arg("t", "any table");
Ret("info", "table information (string)")
EndArgs();
Separator();
Title1("Media");
VarEntry("VIDEO_WIDTH");
Desc("Video width. (number, video script only)");
VarEntry("VIDEO_HEIGHT");
Desc("Video height. (number, video script only)");
VarEntry("VIDEO_HAS_ALPHA");
Desc("Video has an alpha channel. (boolean, video script only)");
VarEntry("VIDEO_FPS");
Desc("Video frames per second. (number, video script only)");
VarEntry("VIDEO_FRAMES");
Desc("Video frames number. (number, video script only)");
VarEntry("AUDIO_CHANNELS");
Desc("Audio channels. (number, audio script only)");
VarEntry("AUDIO_SAMPLE_RATE");
Desc("Audio samples per second (per channel). (number, audio script only)");
VarEntry("AUDIO_SAMPLES");
Desc("Audio samples number (for all channels). (number, audio script only)");
VarEntry("USERDATA");
Desc("Passed data string from LVS call. (string, avisynth only)");
Separator();
Title1("G2D library");
Title2("Image creation");
FuncEntry("image", "g2d.create_image", "format, width, height");
Desc("Creates an image with given size and colorspace.");
BeginArgs();
Arg("format", '"RGBA", "RGB", "ALPHA" or "BINARY"');
Arg("width, height", "size (number)");
Ret("image", "image object");
EndArgs();
FuncEntry("image", "g2d.create_image_from_png", "filename");
Desc("Creates an image from a PNG file.");
BeginArgs();
Arg("filename", "name of a PNG file (string)");
Ret("image", "image object");
EndArgs();
FuncEntry("", "g2d.create_png_from_image", "image, filename");
Desc("Creates a PNG file from an image.");
BeginArgs();
Arg("image", "image object");
Ret("filename", "name of a new PNG file (string)");
EndArgs();
Title2("Matrix creation");
FuncEntry("matrix", "g2d.create_matrix", "");
Desc("Creates a matrix.");
BeginArgs();
Ret("matrix", "matrix object");
EndArgs();
Title2("Source creation");
FuncEntry("source", "g2d.create_color", "r, g, b[, a]");
Desc("Creates a source of given color.");
BeginArgs();
Arg("r, g, b, a", "color strength in range 0-1 (number)");
Ret("source", "source object");
EndArgs();
FuncEntry("source", "g2d.create_lgradient", "x0, y0, x1, y1");
Desc("Creates a source as color gradient along given vector.");
BeginArgs();
Arg("x0, y0, x1, y1", "vector (number)");
Ret("source", "source object");
EndArgs();
FuncEntry("source", "g2d.create_rgradient", "cx0, cy0, r0, cx1, cy1, r1");
Desc("Creates a source as color gradient along two circles.");
BeginArgs();
Arg("cx0, cy0, r0, cx1, cy1, r1", "circles (number)");
Ret("source", "source object");
EndArgs();
FuncEntry("source", "g2d.create_mgradient", "");
Desc("Creates a source as color gradient meshes.");
BeginArgs();
Ret("source", "source object");
EndArgs();
FuncEntry("source", "g2d.create_pattern", "image");
Desc("Creates a source from given image.");
BeginArgs();
Arg("image", "image object");
Ret("source", "source object");
EndArgs();
Title2("Utilities");
FuncEntry("width, height, ascent, descent, internal_leading, external_leading", "g2d.text_extents", "text, face, size[, bold, italic, underline, strikeout]");
Desc("Calculates text extents and font metrics.");
BeginArgs();
Arg("text", "any text (string)");
Arg("face", "font face (string)");
Arg("size", "font size (number)");
Arg("bold, italic, underline, strikeout", "font style (boolean, optional)");
Ret("width, height", "text extents (number)");
Ret("ascent, descent, internal_leading, external_leading", "font metrics (number)");
EndArgs();
Separator();
Title1("Image object");
Title2("Header data");
FuncEntry("width", "image:get_width", "");
Desc("Returns image width.");
BeginArgs();
Ret("width", "image width (number)");
EndArgs();
FuncEntry("height", "image:get_height", "");
Desc("Returns image height.");
BeginArgs();
Ret("height", "image height (number)");
EndArgs();
FuncEntry("format", "image:get_format", "");
Desc("Returns image format/colorspace.");
BeginArgs();
Ret("format", '"RGBA", "RGB", "ALPHA" or "BINARY"');
EndArgs();
Title2("Pixels data");
FuncEntry("pixels", "image:get_data", "x0, y0, x1, y1");
Desc("Returns image data of given area.");
BeginArgs();
Arg("x0, y0, x1, y1", "image area (number)");
Ret("pixels", "pixels palette (table)");
EndArgs();
FuncEntry("", "image:set_data", "x0, y0, x1, y1, pixels");
Desc("Sets image data to given area.");
BeginArgs();
Arg("x0, y0, x1, y1", "image area (number)");
Arg("pixels", "pixels palette (table)");
EndArgs();
Title2("Context");
FuncEntry("context", "image:get_context", "");
Desc("Creates an image drawing context.");
BeginArgs();
Ret("context", "context object");
EndArgs();
Title2("Manipulation");
FuncEntry("image", "image:convolute", "kernel");
Desc("Applies given convolution filter kernel to image.");
BeginArgs();
Arg("kernel", "convolution kernel with fields <i>width</i>, <i>height</i> and kernel elements (table)");
Ret("image", "image object from input");
EndArgs();
Separator();
Title1("Matrix object");
Title2("Data");
FuncEntry("xx, yx, xy, yy, x0, y0", "matrix:get_data", "");
Desc("Returns matrix values.");
BeginArgs();
Ret("xx, yx, xy, yy, x0, y0", "matrix fields (number)");
EndArgs();
FuncEntry("", "matrix:set_data", "xx, yx, xy, yy, x0, y0");
Desc("Sets matrix values.");
BeginArgs();
Arg("xx, yx, xy, yy, x0, y0", "matrix fields (number)");
EndArgs();
Title2("Manipulation");
FuncEntry("matrix", "matrix:identity", "");
Desc("Sets matrix to identity.");
BeginArgs();
Ret("matrix", "matrix object from input");
EndArgs();
FuncEntry("matrix", "matrix:invert", "");
Desc("Inverts matrix.");
BeginArgs();
Ret("matrix", "matrix object from input");
EndArgs();
FuncEntry("matrix", "matrix:multiply", "xx, yx, xy, yy, x0, y0");
Desc("Multiplies matrix with given matrix.");
BeginArgs();
Arg("xx, yx, xy, yy, x0, y0", "matrix fields (number)");
Ret("matrix", "matrix object from input");
EndArgs();
FuncEntry("matrix", "matrix:translate", "x, y");
Desc("Prepends translation to matrix.");
BeginArgs();
Arg("x, y", "translation (number)");
Ret("matrix", "matrix object from input");
EndArgs();
FuncEntry("matrix", "matrix:scale", "x, y");
Desc("Prepends scaling to matrix.");
BeginArgs();
Arg("x, y", "scale (number)");
Ret("matrix", "matrix object from input");
EndArgs();
FuncEntry("matrix", "matrix:rotate", "angle");
Desc("Prepends z-axis rotation to matrix.");
BeginArgs();
Arg("angle", "rotation angle (number)");
Ret("matrix", "matrix object from input");
EndArgs();
FuncEntry("matrix", "matrix:shear", "x, y");
Desc("Prepends shearing to matrix.");
BeginArgs();
Arg("x, y", "shear (number)");
Ret("matrix", "matrix object from input");
EndArgs();
Title2("Transformation");
FuncEntry("x, y", "matrix:transform", "x, y");
Desc("Multiplies point with matrix.");
BeginArgs();
Arg("x, y", "point (number)");
Ret("x, y", "transformed point (number)");
EndArgs();
Separator();
Title1("Source object");
Title2("Add data");
FuncEntry("source", "source:add_color", "pct, r, g, b[, a]");
Desc("Adds a color to color gradient source.");
BeginArgs();
Arg("pct", "gradient offset in range 0-1 (number)");
Arg("r, g, b", "color strength in range 0-1 (number)");
Arg("a", "alpha strength in range 0-1 (number, optional)");
Ret("source", "source object from input");
EndArgs();
FuncEntry("source", "source:add_mesh", "x0, y0, r0, g0, b0, a0, x1, y1, r1, g1, b1, a1, x2, y2, r2, g2, b2, a2[, x3, y3, r3, g3, b3, a3]");
Desc("Adds a color gradient mesh to meshes source.");
BeginArgs();
Arg("x0, y0, r0, g0, b0, a0, x1, y1, r1, g1, b1, a1, x2, y2, r2, g2, b2, a", "mesh points and colors in range 0-1 (number)");
Arg("x3, y3, r3, g3, b3, a3", "fourth mesh point and color (number, optional)");
Ret("source", "source object from input");
EndArgs();
Title2("Get data");
FuncEntry("[pct, ]r, g, b, a", "source:get_color", "[index]");
Desc("Returns (gradient offset and) color of color (gradient) source.");
BeginArgs();
Arg("index", "color index in color gradient source (number, optional)");
Ret("pct", "gradient offset in range 0-1 (number, case-dependent)");
Ret("r, g, b, a", "color and alpha in range 0-1 (number)");
EndArgs();
FuncEntry("x0, y0, x1, y1", "source:get_points", "");
Desc("Returns vector of linear color gradient.");
BeginArgs();
Ret("x0, y0, x1, y1", "vector (number)");
EndArgs();
FuncEntry("cx0, cy0, r0, cx1, cy1, r1", "source:get_circles", "");
Desc("Returns circles of radial color gradient.");
BeginArgs();
Ret("cx0, cy0, r0, cx1, cy1, r1", "circles (number)");
EndArgs();
FuncEntry("x0, y0, r0, g0, b0, a0, x1, y1, r1, g1, b1, a1, x2, y2, r2, g2, b2, a2, x3, y3, r3, g3, b3, a3", "source:get_mesh", "index");
Desc("Returns a mesh from color gradient mesh source.");
BeginArgs();
Arg("index", "mesh index in color gradient mesh source (number)");
Ret("x0, y0, r0, g0, b0, a0, x1, y1, r1, g1, b1, a1, x2, y2, r2, g2, b2, a2, x3, y3, r3, g3, b3, a3", "mesh (number)");
EndArgs();
FuncEntry("image", "source:get_image", "");
Desc("Returns image of image source.");
BeginArgs();
Ret("image", "image object");
EndArgs();
Title2("Properties");
FuncEntry("type", "source:get_type", "");
Desc("Returns source type.");
BeginArgs();
Ret("type", '"COLOR", "LINEAR_GRADIENT", "RADIAL_GRADIENT", "MESH_GRADIENT" or "IMAGE"');
EndArgs();
FuncEntry("extender", "source:get_extender", "");
Desc("Returns source edge extension mode.");
BeginArgs();
Ret("extender", '"NONE", "REPEAT", "MIRROR" or "FLOW"');
EndArgs();
FuncEntry("", "source:set_extender", "extender");
Desc("Sets source edge extension mode.");
BeginArgs();
Arg("extender", '"NONE", "REPEAT", "MIRROR" or "FLOW"');
EndArgs();
FuncEntry("filter", "source:get_filter", "");
Desc("Returns source transformation filter.");
BeginArgs();
Ret("filter", '"FAST", "GOOD" or "BEST"');
EndArgs();
FuncEntry("", "source:set_filter", "filter");
Desc("Sets source transformation filter.");
BeginArgs();
Arg("filter", '"FAST", "GOOD" or "BEST"');
EndArgs();
FuncEntry("matrix", "source:get_matrix", "");
Desc("Returns source transformation matrix.");
BeginArgs();
Ret("matrix", "matrix object");
EndArgs();
FuncEntry("", "source:set_matrix", "matrix");
Desc("Sets source transformation matrix.");
BeginArgs();
Arg("matrix", "matrix object");
EndArgs();
Separator();
Title1("Context object");
Title2("State");
FuncEntry("", "context:push_state", "");
Desc("Pushes current context state onto the internal state stack.");
FuncEntry("", "context:pop_state", "");
Desc("Pops a context state from the internal state stack and sets it as current.");
Title2("Transformation");
FuncEntry("matrix", "context:get_matrix", "");
Desc("Returns context transformation matrix.");
BeginArgs();
Ret("matrix", "matrix object");
EndArgs();
FuncEntry("", "context:set_matrix", "matrix");
Desc("Sets context transformation matrix.");
BeginArgs();
Arg("matrix", "matrix object");
EndArgs();
Title2("Raster source");
FuncEntry("source", "context:get_source", "");
Desc("Returns context source.");
BeginArgs();
Ret("source", "source object");
EndArgs();
FuncEntry("", "context:set_source", "source");
Desc("Sets context source.");
BeginArgs();
Arg("source", "source object");
EndArgs();
Title2("Render properties");
FuncEntry("antialiasing", "context:get_antialiasing", "");
Desc("Returns antialiasing mode.");
BeginArgs();
Ret("antialiasing", "antialiasing mode (boolean)");
EndArgs();
FuncEntry("", "context:set_antialiasing", "antialiasing");
Desc("Sets antialiasing mode.");
BeginArgs();
Arg("antialiasing", "antialiasing mode (boolean)");
EndArgs();
FuncEntry("fill_rule", "context:get_fill_rule", "");
Desc("Returns filling rule.");
BeginArgs();
Ret("fill_rule", '"WINDING" or "ODD"');
EndArgs();
FuncEntry("", "context:set_fill_rule", "fill_rule");
Desc("Sets filling rule.");
BeginArgs();
Arg("fill_rule", '"WINDING" or "ODD"');
EndArgs();
FuncEntry("composition", "context:get_composition", "");
Desc("Returns composition.");
BeginArgs();
Ret("composition", '"SOURCE", "OVER", "INSIDE", "OUTSIDE", "MIX", "XOR", "ADD", "SATURATE", "MULTIPLY" or "DIFFERENCE"');
EndArgs();
FuncEntry("", "context:set_composition", "composition");
Desc("Sets composition.");
BeginArgs();
Arg("composition", '"SOURCE", "OVER", "INSIDE", "OUTSIDE", "MIX", "XOR", "ADD", "SATURATE", "MULTIPLY" or "DIFFERENCE"');
EndArgs();
Title2("Stroke properties");
FuncEntry("offset, dashes", "context:get_dash", "");
Desc("Returns the dash pattern for path stroking.");
BeginArgs();
Ret("offset", "dash pattern offset for stroke start (number)");
Ret("dashes", "length of 'on' and 'off' portions in stroke (table of numbers)");
EndArgs();
FuncEntry("", "context:set_dash", "offset, dashes");
Desc("Sets the dash pattern for path stroking.");
BeginArgs();
Arg("offset", "dash pattern offset for stroke start (number)");
Arg("dashes", "length of 'on' and 'off' portions in stroke (table of numbers)");
EndArgs();
FuncEntry("line_cap", "context:get_line_cap", "");
Desc("Returns line cap.");
BeginArgs();
Ret("line_cap", '"FLAT", "ROUND" or "SQUARE"');
EndArgs();
FuncEntry("", "context:set_line_cap", "line_cap");
Desc("Sets line cap.");
BeginArgs();
Arg("line_cap", '"FLAT", "ROUND" or "SQUARE"');
EndArgs();
FuncEntry("line_join", "context:get_line_join", "");
Desc("Returns line join.");
BeginArgs();
Ret("line_join", '"MITER", "ROUND" or "BEVEL"');
EndArgs();
FuncEntry("", "context:set_line_join", "line_join");
Desc("Sets line join.");
BeginArgs();
Arg("line_join", '"MITER", "ROUND" or "BEVEL"');
EndArgs();
FuncEntry("miter_limit", "context:get_miter_limit", "");
Desc("Returns miter join width limit.");
BeginArgs();
Ret("miter_limit", "miter limit (number)");
EndArgs();
FuncEntry("", "context:set_miter_limit", "miter_limit");
Desc("Sets miter join width limit.");
BeginArgs();
Arg("miter_limit", "miter limit (number)");
EndArgs();
FuncEntry("width", "context:get_line_width", "");
Desc("Returns line width.");
BeginArgs();
Ret("width", "line width (number)");
EndArgs();
FuncEntry("", "context:set_line_width", "width");
Desc("Sets line width.");
BeginArgs();
Arg("width", "line width (number)");
EndArgs();
Title2("Clipping");
FuncEntry("", "context:clip_from_path", "");
Desc("Defines clipping region from current path.");
FuncEntry("", "context:clip_clear", "");
Desc("Clears clipping region.");
FuncEntry("rectangles", "context:clip_get_rectangles", "");
Desc("Returns clipping region describing rectangles.");
BeginArgs();
Ret("rectangles", "rectangles with fields <i>x</i>, <i>y</i>, <i>width</i> and <i>height</i> (tables in table)");
EndArgs();
Title2("Path definition");
FuncEntry("", "context:path_move_to", "x, y");
Desc("Adds a movement to current path.");
BeginArgs();
Arg("x, y", "point (number)");
EndArgs();
FuncEntry("", "context:path_line_to", "x, y");
Desc("Adds a line to current path.");
BeginArgs();
Arg("x, y", "point (number)");
EndArgs();
FuncEntry("", "context:path_curve_to", "x0, y0, x1, y1, x2, y2");
Desc("Adds a cubic bezier curve to current path.");
BeginArgs();
Arg("x0, y0, x1, y1, x2, y2", "points (number)");
EndArgs();
FuncEntry("", "context:path_add_rectangle", "x, y, width, height");
Desc("Adds a closed rectangle to current path.");
BeginArgs();
Arg("x, y", "upper-left point of rectangle (number)");
Arg("width, height", "dimension of rectangle (number)");
EndArgs();
FuncEntry("", "context:path_add_arc", "cx, cy, r, angle0, angle1");
Desc("Adds an arc to current path.");
BeginArgs();
Arg("cx, cy, r", "arc (number)");
Arg("angle0, angle1", "start and end angle of arc (number)");
EndArgs();
FuncEntry("", "context:path_add_text", "text, face, size[, bold, italic, underline, strikeout]");
Desc("Adds a closed text to current path.");
BeginArgs();
Arg("text", "any text (string)");
Arg("face", "font face (string)");
Arg("size", "font size (number)");
Arg("bold, italic, underline, strikeout", "font style (boolean, optional)");
EndArgs();
FuncEntry("", "context:path_close", "");
Desc("Closes current path.");
FuncEntry("", "context:path_clear", "");
Desc("Clears path.");
FuncEntry("", "context:path_transform", "filter[, flatten]");
Desc("Passes current path points through a filter function for manipulation.");
BeginArgs();
Arg("filter", "path points filter (function, [type_string,x,y -> x,y])");
Arg("flatten", "curves flattened before? (boolean)");
EndArgs();
Title2("Drawing");
FuncEntry("", "context:fill", "");
Desc("Fills path with source.");
FuncEntry("", "context:stroke", "");
Desc("Strokes path with source.");
FuncEntry("", "context:paint", "");
Desc("Paints source completely.");
FuncEntry("", "context:masked_paint", "mask");
Desc("Paints source with alpha mask.");
BeginArgs();
Arg("mask", "source object");
EndArgs();
Title2("Bounding");
FuncEntry("x0, y0, x1, y1", "context:clip_bounding", "");
Desc("Calculates the bounding box/area of the clipping region.");
BeginArgs();
Ret("x0, y0, x1, y1", "area (number)");
EndArgs();
FuncEntry("x0, y0, x1, y1", "context:path_bounding", "");
Desc("Calculates the bounding box/area of all path points.");
BeginArgs();
Ret("x0, y0, x1, y1", "area (number)");
EndArgs();
FuncEntry("x0, y0, x1, y1", "context:fill_bounding", "");
Desc("Calculates the bounding box/area of the filling path.");
BeginArgs();
Ret("x0, y0, x1, y1", "area (number)");
EndArgs();
FuncEntry("x0, y0, x1, y1", "context:stroke_bounding", "");
Desc("Calculates the bounding box/area of the stroking path.");
BeginArgs();
Ret("x0, y0, x1, y1", "area (number)");
EndArgs();
Title2("Point test");
FuncEntry("hit", "context:clip_contains", "x, y");
Desc("Checks if point is inside of the clipping region.");
BeginArgs();
Arg("x, y", "point (number)");
Ret("hit", "is inside (boolean)");
EndArgs();
FuncEntry("hit", "context:fill_contains", "x, y");
Desc("Checks if point is inside of the filling path.");
BeginArgs();
Arg("x, y", "point (number)");
Ret("hit", "is inside (boolean)");
EndArgs();
FuncEntry("hit", "context:stroke_contains", "x, y");
Desc("Checks if point is inside of the stroking path.");
BeginArgs();
Arg("x, y", "point (number)");
Ret("hit", "is inside (boolean)");
EndArgs();
Separator();
Title1("G2DU library");
Title2("Stock objects");
VarEntry("g2du.identity");
Desc("Identity matrix.");
VarEntry("g2du.flip_h");
Desc("Horizontal flip matrix.");
VarEntry("g2du.flip_v");
Desc("Vertical flip matrix.");
VarEntry("g2du.white");
Desc("White color source.");
VarEntry("g2du.black");
Desc("Black color source.");
VarEntry("g2du.grey");
Desc("Grey color source.");
VarEntry("g2du.dark_grey");
Desc("Dark grey color source.");
VarEntry("g2du.bright_grey");
Desc("Bright grey color source.");
VarEntry("g2du.red");
Desc("Red color source.");
VarEntry("g2du.dark_red");
Desc("Dark red color source.");
VarEntry("g2du.bright_red");
Desc("Bright red color source.");
VarEntry("g2du.green");
Desc("Green color source.");
VarEntry("g2du.dark_green");
Desc("Dark green color source.");
VarEntry("g2du.bright_green");
Desc("Bright green color source.");
VarEntry("g2du.blue");
Desc("Blue color source.");
VarEntry("g2du.dark_blue");
Desc("Dark blue color source.");
VarEntry("g2du.bright_blue");
Desc("Bright blue color source.");
VarEntry("g2du.yellow");
Desc("Yellow color source.");
VarEntry("g2du.dark_yellow");
Desc("Dark yellow color source.");
VarEntry("g2du.bright_yellow");
Desc("Bright yellow color source.");
VarEntry("g2du.aqua");
Desc("Aqua color source.");
VarEntry("g2du.dark_aqua");
Desc("Dark aqua color source.");
VarEntry("g2du.bright_aqua");
Desc("Bright aqua color source.");
VarEntry("g2du.purple");
Desc("Purple color source.");
VarEntry("g2du.dark_purple");
Desc("Dark purple color source.");
VarEntry("g2du.bright_purple");
Desc("Bright purple color source.");
VarEntry("g2du.orange");
Desc("Orange color source.");
VarEntry("g2du.lime");
Desc("Lime color source.");
VarEntry("g2du.spring");
Desc("Spring color source.");
VarEntry("g2du.azure");
Desc("Azure color source.");
VarEntry("g2du.pink");
Desc("Pink color source.");
VarEntry("g2du.violet");
Desc("Violet color source.");
VarEntry("g2du.brown");
Desc("Brown color source.");
VarEntry("g2du.sapphire");
Desc("Sapphire color source.");
VarEntry("g2du.transparent");
Desc("Transparent color source.");
Title2("Image conversion");
FuncEntry("image", "g2du.create_sub_image", "image, format, x0, y0, x1, y1");
Desc("Creates a subimage with new colorspace of given image.");
BeginArgs();
Arg("image", "image object");
Arg("format", '"RGBA", "RGB", "ALPHA" or "BINARY"');
Arg("x0, y0, x1, y1", "image area (number)");
Ret("image", "image object");
EndArgs();
FuncEntry("pixels", "g2du.get_pixels", "image");
Desc("Creates a pixels table of 'visible' image pixels. 'Visible' means <i>alpha > 0</i> in RGBA, <i>not black</i> in RGB or <i>value > 0</i> in ALPHA or BINARY.");
BeginArgs();
Arg("image", "image object");
Ret("pixels", "pixels informations with fields <i>r</i>, <i>g</i>, <i>b</i>, <i>a</i>, <i>x</i> and <i>y</i> (tables in table)");
EndArgs();
Title2("Kernel generation");
FuncEntry("kernel", "g2du.create_box_blur_kernel", "r")
Desc("Generates a box blur filter kernel.");
BeginArgs();
Arg("r", "kernel radius (number, integer)");
Ret("kernel", "filter kernel (table)");
EndArgs();
FuncEntry("kernel", "g2du.create_gaussian_blur_kernel", "r")
Desc("Generates a gaussian blur filter kernel.");
BeginArgs();
Arg("r", "kernel radius (number, integer)");
Ret("kernel", "filter kernel (table)");
EndArgs();
FuncEntry("kernel", "g2du.create_motion_blur_kernel", "r, angle")
Desc("Generates a motion blur filter kernel.");
BeginArgs();
Arg("r", "kernel radius (number, integer)");
Arg("angle", "blur direction as angle (number)");
Ret("kernel", "filter kernel (table)");
EndArgs();
FuncEntry("kernel", "g2du.create_sharpen_kernel", "r")
Desc("Generates a sharpen filter kernel.");
BeginArgs();
Arg("r", "kernel radius (number, integer)");
Ret("kernel", "filter kernel (table)");
EndArgs();
FuncEntry("kernel", "g2du.create_edge_detect_kernel", "r")
Desc("Generates an edge detection filter kernel.");
BeginArgs();
Arg("r", "kernel radius (number, integer)");
Ret("kernel", "filter kernel (table)");
EndArgs();
Title2("Matrix manipulation");
FuncEntry("mat", "g2du.rotate_xy", "mat, x, y")
Desc("Prepends x-axis + y-axis rotation to matrix.");
BeginArgs();
Arg("mat", "matrix object");
Arg("x, y", "angles (number)");
Ret("mat", "matrix object from input");
EndArgs();
FuncEntry("mat", "g2du.rotate_yx", "mat, x, y")
Desc("Prepends y-axis + x-axis rotation to matrix.");
BeginArgs();
Arg("mat", "matrix object");
Arg("x, y", "angles (number)");
Ret("mat", "matrix object from input");
EndArgs();
Title2("Path manipulation");
FuncEntry("", "g2du.path_transform", "ctx, filter")
Desc("Splits context path into tiny line segments and passes their points through a filter function for manipulation.");
BeginArgs();
Arg("ctx", "context object");
Ret("filter", "path points filter (function, [x,y -> x,y])");
EndArgs();
</script>
<!--
FuncEntry("", "", "")
Desc("");
BeginArgs();
Arg("", "");
Ret("", "");
EndArgs();
-->
<script>
document.getElementById("index").innerHTML = index_buffer;
</script>
</body>

</html>